Здравствуйте. Можете, пожалуйста, посмотреть один вопрос из 4-й домашки. 
Суть была - добавить на страницу с постами поле для ввода комментария

"""запуск hw4/add_comment/id""" (задача в приложении hw_app4)

Код у меня такой. Тут коммент заполняется, дается POST запрос, коммент сохраняется в базу и возвращается 
страничка статьи с пустой формой для ввода нового комментария. 
Проблема, что когда при этом обновляешь страницу, то предыдущий комментарий опять записывается в БД, он где-то в памяти 
остался. Что я могу скорректировать в коде, чтобы этого не было? 

def add_comment(request, post_id):
    post = Post.objects.filter(pk=post_id).first()
    post.views_num += 1
    post.save()
    comments = Comment.objects.filter(post=post).order_by("updated")
    if request.method == "POST":
        form = CommentForm(request.POST)
        if form.is_valid():
            text = form.cleaned_data["text"]
            new_comment = Comment(author=post.author, post=post, text=text)
            new_comment.save()
            form = CommentForm()
    else:
        form = CommentForm()
    context = {"post": post, "comments": comments, "form": form}
    return render(request, "hw_app4/post_comment.html", context)



Как найти(отфильтровать) заказы, где есть конкретный продукт (поле search_fields)? 
Продукты - свойство items в модели Order (поле ManytoMany)

class Order(models.Model):
    client = models.ForeignKey(
        Customer, on_delete=models.CASCADE, related_name="orders"
    )
    items = models.ManyToManyField(Products, related_name="in_order")
    total_price = models.DecimalField(max_digits=10, decimal_places=2)
    created = models.DateTimeField(auto_now_add=True)
    updated = models.DateTimeField(auto_now=True)

class OrderAdmin(admin.ModelAdmin):
    list_display = ["client", "total_price", "created", "updated"]
    actions = [change_update]
    ordering = ["created"]
    list_per_page = 10
    # search_fields = ["items"] - не работает
    list_filter = ["created"]

Посмотрите,пожалуйста, эти 2 actions для Customer(даже любую одну, они однотипные. 
Можно ли это было как-то иначе сделать, получше вариант? 

@admin.action(description="Update phone number")
def phone_update(modeladmin, request, queryset):
    clients = queryset.filter(phone__startswith="+994").all()
    for client in clients:
        client.phone = client.phone.replace("+994", "+554")
        client.save()


@admin.action(description="Email correction")
def email_correct(modeladmin, request, queryset):
    clients = queryset.exclude(email__endswith="@mail.ru")
    for client in clients:
        client.email = f"{client.email}@mail.ru"
        client.save()